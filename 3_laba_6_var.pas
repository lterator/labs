var E,x,res,step,k:real;
    i:integer;
   
//Создаем переменные: 
//E - точность(0.000001, чем меньше E, тем правильнее результат)
//x - вводимое число
//res - сюда записываем результат(для вывода вконце)
//step - шаг, запоминаем старое число(нужно для алгоритма)
//k - коэффицент
//i - номер элемента

begin
    readln(E);
    readln(x);
    //считали данные
    res:=1;
    //результат 1, так как в последовательности 1 елемент всегда равен 1, исходя из формулы x**0/0!=1/1=1
    step:=res;
    //запоминаем старое число - 1
    i:=0;
    //начинаем с 0 элемента
    while step>E do begin
       //алгоритм работает пока значение n-элемента больше E(точности)
       
       //описание алгоритма:
       //n-элемент считается по формуле x**n/n!
       //так как для нас очень долго считать такие числа поступим так
       //запишем формулу n-элемента и n+1-элемента
       //x**n/n! и x**(n+1)/(n+1)!
       //понятно что есть такое число k при котором данное равенство верно
       //x**n/n! * k = x**(n+1)/(n+1)!
       //найдем k
       //k = (x**(n+1)/x**(n))*(n!/(n+1)!)
       //k = (x)/(n!*(n+1)/n!)
       //k = x/(n+1)
       //теперь мы можем найти n-элемент зная n-1 элемент по формуле
       //n-элемент = k*(n-1 элемент)
       
       k:=x/(i+1);
       //нашли k
       res:=res+k*step;
       //нашли n - прибавили к сумме
       step:=k;
       //обновили число
       i:=i+1;
    end;
    writeln(res);
    //вывод
end.